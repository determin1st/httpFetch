// Generated by LiveScript 1.6.0
"use strict";
var soFetch, assert;
soFetch = null;
assert = null;
window.addEventListener('load', async function(){
  var isLocal, server, a;
  isLocal = window.location.href.indexOf('local') !== -1;
  server = isLocal ? 'http://localhost' : 'http://46.4.19.13:30980';
  soFetch = httpFetch.create({
    baseUrl: server + '/api/http-fetch',
    timeout: 0
  });
  if (!isLocal) {
    console.log('httpFetch: remote version is ' + (await soFetch('')));
    if (!deepEq$((await soFetch('/tests')), true, '===')) {
      soFetch = null;
      console.log('httpFetch: test interface is disabled');
      return;
    }
    if (!window.test) {
      console.log('httpFetch: test function is not defined');
      return;
    }
  }
  window.assert = function(title, expect){
    title = '%c' + title;
    return function(res){
      var font;
      if (res instanceof Error) {
        if (res.id) {
          res = 'FetchError(' + res.id + ')[' + res.status + ']: %c' + res.message + ' ';
        } else {
          res = 'Error: %c' + res.message;
        }
        expect = !expect;
      } else {
        res = 'success(%c' + res + ')';
      }
      expect = expect ? 'color:green' : 'color:red';
      font = 'font-weight:bold;';
      console.log(title + '%c' + res, font, font + expect, expect);
    };
  };
  window.help = {
    base64ToBuf: function(str){
      var a, b, c, d;
      a = atob(str);
      b = a.length;
      c = new Uint8Array(b);
      d = -1;
      while (++d < b) {
        c[d] = a.charCodeAt(d);
      }
      return c;
    },
    bufToHex: function(){
      var hex, i, n;
      hex = [];
      i = -1;
      n = 256;
      while (++i < n) {
        hex[i] = i.toString(16).padStart(2, '0');
      }
      return function(buf){
        var a, b, i, n;
        a = new Uint8Array(buf);
        b = [];
        i = -1;
        n = a.length;
        while (++i < n) {
          b[i] = hex[a[i]];
        }
        return b.join('');
      };
    }()
  };
  if (a = document.querySelector('code.javascript')) {
    a.innerHTML = test.toString();
  }
  hljs.initHighlighting();
  test();
});
function deepEq$(x, y, type){
  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
      has = function (obj, key) { return hasOwnProperty.call(obj, key); };
  var first = true;
  return eq(x, y, []);
  function eq(a, b, stack) {
    var className, length, size, result, alength, blength, r, key, ref, sizeB;
    if (a == null || b == null) { return a === b; }
    if (a.__placeholder__ || b.__placeholder__) { return true; }
    if (a === b) { return a !== 0 || 1 / a == 1 / b; }
    className = toString.call(a);
    if (toString.call(b) != className) { return false; }
    switch (className) {
      case '[object String]': return a == String(b);
      case '[object Number]':
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        return +a == +b;
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') { return false; }
    length = stack.length;
    while (length--) { if (stack[length] == a) { return true; } }
    stack.push(a);
    size = 0;
    result = true;
    if (className == '[object Array]') {
      alength = a.length;
      blength = b.length;
      if (first) {
        switch (type) {
        case '===': result = alength === blength; break;
        case '<==': result = alength <= blength; break;
        case '<<=': result = alength < blength; break;
        }
        size = alength;
        first = false;
      } else {
        result = alength === blength;
        size = alength;
      }
      if (result) {
        while (size--) {
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
        }
      }
    } else {
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
        return false;
      }
      for (key in a) {
        if (has(a, key)) {
          size++;
          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
        }
      }
      if (result) {
        sizeB = 0;
        for (key in b) {
          if (has(b, key)) { ++sizeB; }
        }
        if (first) {
          if (type === '<<=') {
            result = size < sizeB;
          } else if (type === '<==') {
            result = size <= sizeB
          } else {
            result = size === sizeB;
          }
        } else {
          first = false;
          result = size === sizeB;
        }
      }
    }
    stack.pop();
    return result;
  }
}