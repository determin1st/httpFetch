// Generated by LiveScript 1.6.0
'use strict';
var httpFetch, toString$ = {}.toString;
httpFetch = function(){
  var api, defaults, HandlerOptions, FetchOptions, FetchError, responseHandler, handler;
  api = {};
  api[typeof fetch] = true;
  api[typeof AbortController] = true;
  api[typeof Proxy] = true;
  if (api['undefined']) {
    console.log('httpFetch: missing requirements');
    return null;
  }
  defaults = {
    timeout: 20,
    only200: true,
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    }
  };
  HandlerOptions = function(url, method){
    this.url = url;
    this.method = method;
    this.data = '';
    this.timeout = defaults.timeout;
  };
  FetchOptions = function(method){
    this.method = method;
    this.headers = defaults.headers;
    this.body = null;
    this.signal = null;
  };
  FetchError = function(){
    var FE;
    if (Error.captureStackTrace) {
      FE = function(message, status){
        this.name = 'FetchError';
        this.message = message;
        this.status = status;
        Error.captureStackTrace(this, FetchError);
      };
    } else {
      FE = function(message, status){
        this.name = 'FetchError';
        this.message = message;
        this.status = status;
        this.stack = new Error(message).stack;
      };
    }
    FE.prototype = Error.prototype;
    return FE;
  }();
  responseHandler = function(r){
    if (!r.ok || (r.status !== 200 && defaults.only200)) {
      throw new FetchError(r.statusText, r.status);
    }
    return r.text().then(function(r){
      var e;
      if (r) {
        try {
          return JSON.parse(r);
        } catch (e$) {
          e = e$;
          throw new Error('Incorrect response body: ' + e.message + ': ' + r);
        }
      }
      return null;
    });
  };
  handler = function(opts, callback){
    var a, o, abrt, timeout;
    if (toString$.call(opts).slice(8, -1) !== 'Object' || typeof callback !== 'function') {
      return false;
    }
    if (opts.hasOwnProperty('method')) {
      a = opts.method;
    } else if (opts.data) {
      a = 'POST';
    } else {
      a = 'GET';
    }
    o = new FetchOptions(a);
    if (opts.data) {
      o.body = typeof opts.data === 'string'
        ? opts.data
        : JSON.stringify(opts.data);
    }
    a = opts.hasOwnProperty('timeout')
      ? opts.timeout
      : defaults.timeout;
    if (a >= 1) {
      abrt = new AbortController();
      o.signal = abrt.signal;
      timeout = setTimeout(function(){
        abrt.abort();
      }, 1000 * a);
    }
    fetch(opts.url, o).then(responseHandler).then(function(r){
      if (timeout) {
        clearTimeout(timeout);
      }
      callback(true, r);
    })['catch'](function(e){
      callback(false, e);
    });
    return true;
  };
  api = {
    post: function(url, data, callback){
      var o;
      o = new HandlerOptions(url, 'POST');
      if (data) {
        o.data = data;
      }
      return handler(o, callback);
    },
    get: function(url, callback){
      return handler(new HandlerOptions(url, 'GET'), callback);
    }
  };
  return new Proxy(handler, {
    get: function(me, key){
      if (api.hasOwnProperty(key)) {
        return api[key];
      }
      return null;
    },
    set: function(me, key, val){
      return true;
    }
  });
}();
if (httpFetch && typeof module !== 'undefined') {
  module.exports = httpFetch;
}