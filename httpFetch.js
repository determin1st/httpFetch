// Generated by LiveScript 1.6.0
'use strict';
var httpFetch, toString$ = {}.toString;
httpFetch = function(){
  var api, Config, RetryConfig, ResponseData, FetchOptions, FetchError, FetchHandlerData, FetchHandler, newPromise, newInstance, apiCrypto, Api, ApiHandler;
  api = [typeof fetch, typeof AbortController, typeof Proxy, typeof Promise];
  if (api.includes('undefined')) {
    console.log('httpFetch: missing requirements');
    return null;
  }
  Config = function(){
    this.baseUrl = '';
    this.status200 = true;
    this.fullSet = false;
    this.noEmpty = false;
    this.timeout = 20;
    this.retry = null;
    this.secret = null;
    this.headers = {
      'accept': 'application/json',
      'content-type': 'application/json; charset=utf-8'
    };
  };
  RetryConfig = function(){
    this.count = 15;
    this.current = 0;
    this.expoBackoff = true;
    this.maxBackoff = 32;
    this.delay = 1;
  };
  ResponseData = function(){
    this.headers = null;
    this.data = null;
  };
  FetchOptions = function(method){
    this.method = method;
    this.body = null;
    this.signal = null;
    this.headers = {};
    this.mode = 'cors';
  };
  FetchError = function(){
    var E;
    if (Error.captureStackTrace) {
      E = function(message, status){
        this.name = 'FetchError';
        this.message = message;
        this.status = status;
        Error.captureStackTrace(this, FetchError);
      };
    } else {
      E = function(message, status){
        this.name = 'FetchError';
        this.message = message;
        this.status = status;
        this.stack = new Error(message).stack;
      };
    }
    E.prototype = Error.prototype;
    return E;
  }();
  FetchHandlerData = function(){
    var this$ = this;
    this.aborter = null;
    this.timeout = 0;
    this.timer = 0;
    this.retry = new RetryConfig();
    this.promise = null;
    this.response = new ResponseData();
    this.timerFunc = function(){
      this$.aborter.abort();
      this$.timer = 0;
    };
  };
  FetchHandler = function(config){
    var jsonParser, newFormData, handler;
    jsonParser = function(r){
      var e;
      if (r) {
        try {
          return JSON.parse(r);
        } catch (e$) {
          e = e$;
          throw new FetchError('Incorrect response: ' + r, 0);
        }
      }
      return config.noEmpty ? {} : null;
    };
    newFormData = function(){
      var add;
      add = function(data, item, key){
        var t, i$, len$, k;
        switch (toString$.call(item).slice(8, -1)) {
        case 'Object':
          t = Object.getOwnPropertyNames(item);
          if (key) {
            for (i$ = 0, len$ = t.length; i$ < len$; ++i$) {
              k = t[i$];
              add(data, item[k], key + '[' + k + ']');
            }
          } else {
            for (i$ = 0, len$ = t.length; i$ < len$; ++i$) {
              k = t[i$];
              add(data, item[k], k);
            }
          }
          break;
        case 'Array':
          t = item.length;
          k = -1;
          if (key) {
            while (++k < t) {
              add(data, item[k], key + '[]');
            }
          } else {
            while (++k < t) {
              add(data, item[k], '');
            }
          }
          break;
        case 'HTMLInputElement':
          if (item.type === 'file' && (t = item.files.length)) {
            add(data, item.files, key);
          }
          break;
        case 'FileList':
          if ((t = item.length) === 1) {
            data.append(key, item[0]);
          } else {
            k = -1;
            while (++k < t) {
              data.append(key + '[]', item[k]);
            }
          }
          break;
        case 'Null':
          data.append(key, '');
          break;
        default:
          data.append(key, item);
        }
        return data;
      };
      return function(o){
        return add(new FormData(), o, '');
      };
    }();
    handler = function(url, options, data, callback){
      var responseHandler, successHandler, errorHandler, handlerFunc;
      responseHandler = function(r){
        var h, a, b;
        if (!r.ok || (r.status !== 200 && config.status200)) {
          throw new FetchError(r.statusText, r.status);
        }
        h = {};
        a = r.headers.entries();
        while (!(b = a.next()).done) {
          h[b.value[0].toLowerCase()] = b.value[1];
        }
        if (options.fullSet) {
          data.response.headers = h;
        }
        a = h['content-type']
          ? h['content-type']
          : options.headers.accept;
        switch (0) {
        case a.indexOf('application/json'):
          return r.text().then(jsonParser);
        case a.indexOf('application/octet-stream'):
          return r.arrayBuffer().then(function(r){
            if (h['content-encoding'] === 'aes256gcm' && config.secret) {
              true;
            }
            return r;
          });
        default:
          return r.text();
        }
      };
      successHandler = function(r){
        if (data.timer) {
          clearTimeout(data.timer);
          data.timer = 0;
        }
        if (options.fullSet) {
          data.response.data = r;
          r = data.response;
        }
        if (callback) {
          callback(true, r);
        } else {
          data.promise.pending = false;
          data.promise.resolve(r);
        }
      };
      errorHandler = function(e){
        var a, b;
        if (data.timer) {
          clearTimeout(data.timer);
          data.timer = 0;
        }
        if (callback && !callback(false, e)) {
          return;
        }
        for (;;) {
          if (!(e instanceof FetchError) || e.status === 0) {
            break;
          }
          if (!(a = data.retry).count || a.current < a.count) {
            break;
          }
          if (a.expoBackoff) {
            b = Math.pow(2, a.current) + Math.floor(1001 * Math.random());
            if (b > a.maxBackoff) {
              b = a.maxBackoff;
            }
          } else {
            if (typeof a.delay === 'number') {
              b = 1000 * a.delay;
            } else {
              if (a.current <= (b = a.delay.length - 1)) {
                b = 1000 * a.delay[a.current];
              } else {
                b = 1000 * a.delay[b];
              }
            }
          }
          ++a.current;
          setTimeout(handlerFunc, b);
          return;
        }
        if (!callback) {
          data.promise.pending = false;
          data.promise.resolve(e);
        }
      };
      return handlerFunc = function(){
        if (data.timeout) {
          data.timer = setTimeout(data.timerFunc, data.timeout);
        }
        fetch(url, options).then(responseHandler).then(successHandler)['catch'](errorHandler);
      };
    };
    this.config = config;
    this.api = new Api(this);
    this.fetch = function(options, callback){
      var a, o, d, b, c;
      if (toString$.call(options).slice(8, -1) !== 'Object') {
        return null;
      }
      a = options.hasOwnProperty('method')
        ? options.method
        : options.data ? 'POST' : 'GET';
      o = new FetchOptions(a);
      d = new FetchHandlerData();
      import$(o.headers, config.headers);
      if (a = options.headers) {
        for (b in a) {
          o.headers[b.toLowerCase()] = a[b];
        }
      }
      if (options.data) {
        a = o.headers['content-type'];
        switch (0) {
        case a.indexOf('application/json'):
          o.body = typeof options.data === 'string'
            ? options.data
            : JSON.stringify(options.data);
          break;
        case a.indexOf('multipart/form-data'):
          o.body = toString$.call(options.data).slice(8, -1) === 'FormData'
            ? options.data
            : newFormData(options.data);
          delete o.headers['content-type'];
          break;
        default:
          if (options.data) {
            o.body = options.data;
          }
        }
      }
      d.aborter = options.aborter
        ? options.aborter
        : new AbortController();
      o.signal = d.aborter.signal;
      a = options.hasOwnProperty('timeout')
        ? options.timeout
        : config.timeout;
      if (a >= 1) {
        d.timeout = 1000 * a;
      }
      a = d.retry;
      if (b = config.retry) {
        for (c in a) {
          a[c] = b[c];
        }
      }
      if (b = options.retry) {
        if (toString$.call(b).slice(8, -1) === 'Object') {
          for (c in a) {
            if (b.hasOwnProperty(c)) {
              a[c] = b[c];
            }
          }
        } else {
          a.count = b;
        }
      }
      a.current = 0;
      a.maxBackoff = 1000 * a.maxBackoff;
      if (!callback) {
        d.promise = newPromise(d.aborter);
      }
      a = options.url
        ? config.baseUrl + options.url
        : config.baseUrl;
      handler(a, o, d, callback)();
      return callback
        ? d.aborter
        : d.promise;
    };
  };
  newPromise = function(aborter){
    var a, b;
    a = null;
    b = new Promise(function(resolve){
      a = resolve;
    });
    b.pending = true;
    b.resolve = a;
    b.controller = aborter;
    b.abort = b.cancel = function(){
      aborter.abort();
    };
    return b;
  };
  newInstance = function(baseConfig){
    return function(userConfig){
      var config, i$, ref$, len$, c, a, ref1$, b;
      config = new Config();
      for (i$ = 0, len$ = (ref$ = [baseConfig, userConfig]).length; i$ < len$; ++i$) {
        c = ref$[i$];
        if (c) {
          for (a in config) {
            if (c.hasOwnProperty(a)) {
              config[a] = c[a];
            }
          }
          if (c.retry) {
            config.retry = import$(new RetryConfig(), c.retry);
          }
          if (c.headers) {
            config.headers = {};
            for (a in ref1$ = c.headers) {
              b = ref1$[a];
              config.headers[a.toLowerCase()] = b;
            }
          }
        }
      }
      a = new FetchHandler(config);
      b = new ApiHandler(a);
      return new Proxy(a.fetch, b);
    };
  };
  apiCrypto = function(){
    if (typeof crypto === 'undefined' || !crypto.subtle) {
      console.log('httpFetch: Crypto API is not supported');
      return null;
    }
    return {
      keyParams: {
        name: 'ECDH',
        namedCurve: 'P-521'
      },
      deriveParams: {
        name: 'HMAC',
        hash: 'SHA-512',
        length: 528
      },
      nullFunc: function(){
        return null;
      },
      generateKeyPair: async function(){
        var k, a;
        k = (await crypto.subtle.generateKey(this.keyParams, true, ['deriveKey'])['catch'](this.nullFunc));
        if (k === null) {
          return null;
        }
        a = (await crypto.subtle.exportKey('spki', k.publicKey)['catch'](this.nullFunc));
        if (a === null) {
          return null;
        }
        return {
          privateKey: k.privateKey,
          publicKey: a
        };
      },
      generateHashPair: async function(){
        var a, b;
        a = (await crypto.subtle.generateKey(this.deriveParams, true, ['sign'])['catch'](this.nullFunc));
        if (a === null) {
          return null;
        }
        a = (await crypto.subtle.exportKey('raw', a)['catch'](this.nullFunc));
        if (a === null) {
          return null;
        }
        b = (await crypto.subtle.digest('SHA-512', a)['catch'](this.nullFunc));
        if (b === null) {
          return null;
        }
        a = new Uint8Array(a);
        b = new Uint8Array(b);
        return [a, b];
      },
      importKey: function(k){
        return crypto.subtle.importKey('spki', k, this.keyParams, true, [])['catch'](this.nullFunc);
      },
      deriveKey: function(privateKey, publicKey){
        return crypto.subtle.deriveKey({
          name: 'ECDH',
          'public': publicKey
        }, privateKey, this.deriveParams, true, ['sign'])['catch'](this.nullFunc);
      },
      bufToHex: function(){
        var hex, i, n;
        hex = [];
        i = -1;
        n = 255;
        while (++i < n) {
          hex[i] = i.toString(16).padStart(2, '0');
        }
        return function(buf){
          var a, b, i, n;
          a = new Uint8Array(buf);
          b = [];
          i = -1;
          n = a.length;
          while (++i < n) {
            b[i] = hex[a[i]];
          }
          return b.join('');
        };
      }(),
      bufToBase64: function(buf){
        var a;
        a = new Uint8Array(buf);
        return btoa(String.fromCharCode.apply(null, a));
      },
      base64ToBuf: function(str){
        var a, b, c, d;
        a = atob(str);
        b = a.length;
        c = new Uint8Array(b);
        d = -1;
        while (++d < b) {
          c[d] = a.charCodeAt(d);
        }
        return c;
      },
      bufToBn: function(buf){
        var hex, u8, c, i, h;
        hex = [];
        u8 = Uint8Array.from(buf);
        c = u8.length;
        i = -1;
        while (++i < c) {
          h = u8[i].toString(16);
          if (h.length % 2) {
            h = '0' + h;
          }
          hex[i] = h;
        }
        return BigInt('0x' + hex.join(''));
      },
      bnToBuf: function(bn, size){
        var hex, len, pad, u8, i, j;
        size == null && (size = 0);
        hex = BigInt(bn).toString(16);
        if (hex.length % 2) {
          hex = '0' + hex;
        }
        len = hex.length / 2;
        if (!size) {
          size = len;
        }
        if ((pad = size - len) < 0) {
          hex = hex.slice(-pad * 2);
          pad = 0;
        }
        u8 = new Uint8Array(size);
        i = pad;
        j = i * 2;
        while (i < size) {
          u8[i] = parseInt(hex.slice(j, j + 2), 16);
          i += 1;
          j += 2;
        }
        return u8;
      },
      newSecret: function(){
        var CipherParams, SecretStorage;
        CipherParams = function(iv){
          this.name = 'AES-GCM';
          this.iv = iv;
          this.tagLength = 128;
        };
        SecretStorage = function(manager, key, iv, current, next){
          this.manager = manager;
          this.key = key;
          this.params = new CipherParams(iv);
          this.current = current;
          this.next = next;
        };
        SecretStorage.prototype = {
          nullFunc: function(){
            return null;
          },
          stringToBuf: TextEncoder.prototype.encode.bind(new TextEncoder()),
          bufToString: TextDecoder.prototype.decode.bind(new TextDecoder('utf-8')),
          encrypt: function(data){
            if (typeof data === 'string') {
              data = this.stringToBuf(data);
            }
            return crypto.subtle.encrypt(this.params, this.key, data)['catch'](this.nullFunc);
          },
          decrypt: function(data){
            return crypto.subtle.decrypt(this.params, this.key, data)['catch'](this.nullFunc);
          }
        };
        return async function(ecdh_secret, manager){
          var s, c, k, c1, c2, n;
          if (!ecdh_secret || ecdh_secret.length < 44) {
            return null;
          }
          ecdh_secret = ecdh_secret.slice(0, 44);
          s = ecdh_secret.slice(0, 32);
          c = ecdh_secret.slice(32, 32 + 12);
          k = (await crypto.subtle.importKey('raw', s, {
            name: 'AES-GCM'
          }, false, ['encrypt', 'decrypt'])['catch'](this.nullFunc));
          if (k === null) {
            return null;
          }
          c1 = this.bufToBn(c.slice(0, 6));
          c2 = this.bufToBn(c.slice(6, 12));
          ++c1;
          ++c2;
          c1 = this.bnToBuf(c1, 6);
          c2 = this.bnToBuf(c2, 6);
          n = new Uint8Array(32 + 12);
          n.set(s, 0);
          n.set(c1, 32);
          n.set(c2, 32 + 6);
          return new SecretStorage(manager, k, c, this.bufToBase64(ecdh_secret), this.bufToBase64(n));
        };
      }()
    };
  }();
  Api = function(handler){
    var handshakeLocked;
    this.create = newInstance(handler.config);
    this.post = function(url, data, callback){
      var o;
      o = {
        url: url,
        method: 'POST',
        data: data ? data : ''
      };
      return handler.fetch(o, callback);
    };
    this.get = function(url, callback){
      var o;
      o = {
        url: url,
        method: 'GET',
        data: ''
      };
      return handler.fetch(o, callback);
    };
    if (!apiCrypto) {
      return;
    }
    handshakeLocked = false;
    this.handshake = async function(url, storeManager){
      var a, k, hash, x, c, b, i;
      if (handshakeLocked) {
        return false;
      }
      if (!storeManager) {
        if (a = handler.config.secret) {
          handler.config.secret = null;
          a.manager('');
        }
        return true;
      }
      handshakeLocked = true;
      if (a = storeManager()) {
        a = apiCrypto.base64ToBuf(a);
        if ((k = (await apiCrypto.newSecret(a, storeManager))) === null) {
          return false;
        }
        handler.config.secret = k;
        handshakeLocked = false;
        return true;
      }
      if (!(hash = (await apiCrypto.generateHashPair()))) {
        handshakeLocked = false;
        return false;
      }
      x = false;
      c = 4;
      while (--c) {
        if (!(k = (await apiCrypto.generateKeyPair()))) {
          break;
        }
        b = {
          url: url,
          method: 'POST',
          data: k.publicKey,
          headers: {
            'accept': 'application/octet-stream',
            'content-type': 'application/octet-stream',
            'content-encoding': 'exchange'
          },
          timeout: 0
        };
        a = (await handler.fetch(b));
        if (!a || a instanceof Error) {
          break;
        }
        if ((a = (await apiCrypto.importKey(a))) === null) {
          break;
        }
        if ((a = (await apiCrypto.deriveKey(k.privateKey, a))) === null) {
          break;
        }
        a = (await crypto.subtle.exportKey('raw', a));
        a = new Uint8Array(a);
        if (a[0] === 0) {
          a = a.slice(1);
        }
        if ((k = (await apiCrypto.newSecret(a, storeManager))) === null) {
          break;
        }
        b.headers['content-encoding'] = 'verify';
        if ((b.data = (await k.encrypt(hash[0]))) === null) {
          break;
        }
        a = (await handler.fetch(b));
        if (!a || !(a instanceof ArrayBuffer)) {
          break;
        }
        if ((i = a.byteLength) !== 0) {
          a = new Uint8Array(a);
          if ((b = hash[1]).byteLength !== i) {
            break;
          }
          while (--i >= 0) {
            if (a[i] !== b[i]) {
              break;
            }
          }
          if (i === -1) {
            x = true;
            break;
          }
        }
      }
      if (x) {
        handler.config.secret = k;
        k.manager(k.current);
      }
      handshakeLocked = false;
      return x;
    };
  };
  ApiHandler = function(handler){
    this.get = function(f, key){
      if (handler.api[key]) {
        return handler.api[key];
      }
      if (handler.config.hasOwnProperty(key)) {
        return handler.config[key];
      }
      return null;
    };
    this.set = function(f, key, val){
      if (handler.config.hasOwnProperty(key)) {
        switch (key) {
        case 'baseURL':
          if (typeof val === 'string') {
            handler.config[key] = val;
          }
          break;
        case 'status200':
        case 'noEmpty':
        case 'fullSet':
          handler.config[key] = !!val;
          break;
        case 'timeout':
          if ((val = parseInt(val)) >= 0) {
            handler.config[key] = val;
          }
        }
      }
      return true;
    };
  };
  return newInstance(null)(null);
}();
if (httpFetch && typeof module !== 'undefined') {
  module.exports = httpFetch;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}