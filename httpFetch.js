// Generated by LiveScript 1.6.0
'use strict';
var httpFetch, toString$ = {}.toString;
httpFetch = function(){
  var api, jsonDecode, jsonEncode, textDecode, textEncode, apiCrypto, parseArguments, isFormData, FetchConfig, FetchOptions, FetchError, FetchData, FetchHandler, Api, ApiHandler, newFormData, newQueryString, newPromise, newInstance;
  api = [typeof fetch, typeof AbortController, typeof Proxy, typeof Promise, typeof WeakMap, typeof TextDecoder];
  if (api.includes('undefined')) {
    console.log('httpFetch: missing requirements');
    return null;
  }
  jsonDecode = function(s){
    var e;
    if (s) {
      try {
        return JSON.parse(s);
      } catch (e$) {
        e = e$;
        throw new FetchError(1, 'incorrect JSON: ' + s, 0);
      }
    }
    return null;
  };
  jsonEncode = function(o){
    try {
      return JSON.stringify(o);
    } catch (e$) {
      e$;
      return null;
    }
  };
  textDecode = function(){
    var t;
    t = new TextDecoder('utf-8');
    return function(buf){
      return t.decode(buf);
    };
  }();
  textEncode = function(){
    var t;
    t = new TextEncoder();
    return function(str){
      return t.encode(str);
    };
  }();
  apiCrypto = function(){
    var CS, nullFunc, bufToHex, hexToBuf, bufToBigInt, bigIntToBuf;
    if (typeof crypto === 'undefined' || !crypto.subtle) {
      console.log('httpFetch: Web Crypto API is not available');
      return null;
    }
    CS = crypto.subtle;
    nullFunc = function(){
      return null;
    };
    bufToHex = function(){
      var hex, i, n;
      hex = [];
      i = -1;
      n = 256;
      while (++i < n) {
        hex[i] = i.toString(16).padStart(2, '0');
      }
      return function(buf){
        var a, b, i, n;
        a = new Uint8Array(buf);
        b = [];
        i = -1;
        n = a.length;
        while (++i < n) {
          b[i] = hex[a[i]];
        }
        return b.join('');
      };
    }();
    hexToBuf = function(hex){
      var len, buf, i, j;
      if ((len = hex.length) % 2) {
        hex = '0' + hex;
        ++len;
      }
      len = len / 2;
      buf = new Uint8Array(len);
      i = -1;
      j = 0;
      while (++i < len) {
        buf[i] = parseInt(hex.slice(j, j + 2), 16);
        j += 2;
      }
      return buf;
    };
    bufToBigInt = function(buf){
      return BigInt('0x' + bufToHex(buf));
    };
    bigIntToBuf = function(bi, size){
      var buf, len, big;
      buf = hexToBuf(bi.toString(16));
      if (!size || (len = buf.length) === size) {
        return buf;
      }
      if (len > size) {
        buf = buf.slice(len - size);
      } else {
        big = new Uint8Array(size);
        big.set(buf, size - len);
        buf = big;
      }
      return buf;
    };
    return {
      cs: CS,
      secretManagersPool: new WeakMap(),
      keyParams: {
        name: 'ECDH',
        namedCurve: 'P-521'
      },
      derivePublicKey: {
        name: 'HMAC',
        hash: 'SHA-512',
        length: 528
      },
      deriveParams: {
        name: 'HMAC',
        hash: 'SHA-512',
        length: 528
      },
      generateKeyPair: async function(){
        var k, a;
        k = (await CS.generateKey(this.keyParams, true, ['deriveKey'])['catch'](nullFunc));
        if (k === null) {
          return null;
        }
        a = (await CS.exportKey('spki', k.publicKey)['catch'](nullFunc));
        return a === null
          ? null
          : [k.privateKey, a];
      },
      generateHashPair: async function(){
        var a, b;
        a = (await CS.generateKey(this.deriveParams, true, ['sign'])['catch'](nullFunc));
        if (a === null) {
          return null;
        }
        a = (await CS.exportKey('raw', a)['catch'](nullFunc));
        if (a === null) {
          return null;
        }
        b = (await CS.digest('SHA-512', a)['catch'](nullFunc));
        if (b === null) {
          return null;
        }
        a = new Uint8Array(a);
        b = new Uint8Array(b);
        return [a, b];
      },
      importKey: function(k){
        return CS.importKey('spki', k, this.keyParams, true, [])['catch'](nullFunc);
      },
      importEcdhKey: function(k){
        return CS.importKey('raw', k, {
          name: 'AES-GCM'
        }, false, ['encrypt', 'decrypt'])['catch'](nullFunc);
      },
      deriveKey: function(privateK, publicK){
        publicK = {
          name: 'ECDH',
          'public': publicK
        };
        return CS.deriveKey(publicK, privateK, this.deriveParams, true, ['sign'])['catch'](nullFunc);
      },
      bufToBase64: function(buf){
        var a;
        a = new Uint8Array(buf);
        return btoa(String.fromCharCode.apply(null, a));
      },
      base64ToBuf: function(str){
        var a, b, c, d;
        a = atob(str);
        b = a.length;
        c = new Uint8Array(b);
        d = -1;
        while (++d < b) {
          c[d] = a.charCodeAt(d);
        }
        return c;
      },
      newSecret: function(){
        var CipherParams, CryptoData, SecretStorage;
        CipherParams = function(iv){
          this.name = 'AES-GCM';
          this.iv = iv;
          this.tagLength = 128;
        };
        CryptoData = function(data, params){
          this.data = data;
          this.params = params;
        };
        SecretStorage = function(manager, secret, key, iv){
          this.manager = manager;
          this.secret = secret;
          this.key = key;
          this.params = new CipherParams(iv);
        };
        SecretStorage.prototype = {
          encrypt: function(data, extended){
            var p;
            if (typeof data === 'string') {
              data = textEncode(data);
            }
            p = new CipherParams(this.params.iv.slice());
            data = CS.encrypt(p, this.key, data)['catch'](nullFunc);
            if (extended) {
              data = new CryptoData(data, p);
              this.next();
            }
            return data;
          },
          decrypt: function(data, params){
            if (typeof data === 'string') {
              data = textEncode(data);
            }
            if (!params) {
              return CS.decrypt(this.params, this.key, data)['catch'](nullFunc);
            }
            params = new CipherParams(params.iv.slice());
            this.next(params.iv);
            data = CS.decrypt(params, this.key, data)['catch'](nullFunc);
            return new CryptoData(data, params);
          },
          next: function(counter){
            var a, b, c, d, e;
            a = counter
              ? counter
              : this.params.iv;
            b = new DataView(a.buffer, 10, 2);
            c = bufToBigInt(a.slice(0, 10));
            d = b.getUint16(0, false);
            if ((e = ++c - 1208925819614629174706176n) >= 0) {
              c = e;
            }
            if ((e = ++d - 65536) >= 0) {
              d = e;
            }
            a.set(bigIntToBuf(c, 10), 0);
            b.setUint16(0, d, false);
            if (!counter) {
              this.secret.set(a, 32);
            }
            return this;
          },
          tag: function(){
            return bufToHex(this.secret.slice(-2));
          },
          save: function(){
            return this.manager('set', apiCrypto.bufToBase64(this.secret)) ? this : null;
          }
        };
        return async function(secret, manager){
          var k, c;
          switch (toString$.call(secret).slice(8, -1)) {
          case 'String':
            secret = apiCrypto.base64ToBuf(secret);
            break;
          case 'CryptoKey':
            secret = (await apiCrypto.cs.exportKey('raw', secret));
            secret = new Uint8Array(secret);
            if (secret[0] === 0) {
              secret = secret.slice(1);
            }
            break;
          default:
            return null;
          }
          if (secret.length < 44) {
            return null;
          }
          secret = secret.slice(0, 44);
          k = secret.slice(0, 32);
          c = secret.slice(32, 32 + 12);
          if ((k = (await apiCrypto.importEcdhKey(k))) === null) {
            return null;
          }
          return new SecretStorage(manager, secret, k, c);
        };
      }()
    };
  }();
  parseArguments = function(a){
    if (!a.length) {
      return new FetchError(3, 'no parameters specified');
    }
    switch (toString$.call(a[0]).slice(8, -1)) {
    case 'String':
      switch (a.length) {
      case 3:
        a[0] = {
          url: a[0],
          data: a[1],
          method: 'POST'
        };
        a[1] = a[2];
        break;
      case 2:
        if (typeof a[1] === 'function') {
          a[0] = {
            url: a[0],
            method: 'GET'
          };
        } else {
          a[0] = {
            url: a[0],
            data: a[1],
            method: 'POST'
          };
          a[1] = false;
        }
        break;
      default:
        a[0] = {
          url: a[0],
          method: 'GET'
        };
        a[1] = false;
      }
      // fallthrough
    case 'Object':
      if (a[0].url && typeof a[0].url !== 'string') {
        return new FetchError(3, 'wrong url type');
      }
      if (a[1] && typeof a[1] !== 'function') {
        return new FetchError(3, 'wrong callback type');
      }
      break;
    default:
      return new FetchError(3, 'incorrect syntax');
    }
    return a;
  };
  isFormData = function(data){
    var a, b;
    switch (toString$.call(data).slice(8, -1)) {
    case 'Object':
      for (a in data) {
        if (isFormData(data[a])) {
          return true;
        }
      }
      break;
    case 'Array':
      b = data.length;
      a = -1;
      while (++a < b) {
        if (isFormData(data[a])) {
          return true;
        }
      }
      break;
    case 'HTMLInputElement':
    case 'FileList':
    case 'File':
    case 'Blob':
      return true;
    }
    return false;
  };
  FetchConfig = function(){
    this.baseUrl = '';
    this.mode = null;
    this.credentials = null;
    this.cache = null;
    this.redirect = null;
    this.referrer = null;
    this.referrerPolicy = null;
    this.integrity = null;
    this.keepalive = null;
    this.status200 = true;
    this.fullHouse = false;
    this.notNull = false;
    this.promiseReject = false;
    this.timeout = 20;
    this.retry = null;
    this.secret = null;
    this.headers = null;
  };
  FetchConfig.prototype = {
    fetchOptions: ['mode', 'credentials', 'cache', 'redirect', 'referrer', 'referrerPolicy', 'integrity', 'keepalive'],
    dataOptions: ['baseUrl', 'timeout'],
    flagOptions: ['status200', 'fullHouse', 'notNull', 'promiseReject'],
    setOptions: function(o){
      var i$, ref$, len$, a;
      for (i$ = 0, len$ = (ref$ = this.fetchOptions).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (o.hasOwnProperty(a)) {
          this[a] = o[a];
        }
      }
      for (i$ = 0, len$ = (ref$ = this.dataOptions).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (o.hasOwnProperty(a)) {
          this[a] = o[a];
        }
      }
      for (i$ = 0, len$ = (ref$ = this.flagOptions).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (o.hasOwnProperty(a)) {
          this[a] = !!o[a];
        }
      }
      if (o.headers) {
        this.setHeaders(o.headers);
      }
    },
    setHeaders: function(s){
      var h, a, b;
      if (!(h = this.headers)) {
        this.headers = h = {};
      }
      for (a in s) {
        b = s[a];
        h[a.toLowerCase()] = b;
      }
    }
  };
  FetchOptions = function(){
    this.method = 'GET';
    this.headers = {
      'content-type': 'application/json'
    };
    this.body = null;
    this.mode = 'cors';
    this.credentials = 'same-origin';
    this.cache = 'default';
    this.redirect = 'follow';
    this.referrer = '';
    this.referrerPolicy = '';
    this.integrity = '';
    this.keepalive = false;
    this.signal = null;
  };
  FetchOptions.prototype = {
    setHeaders: function(s){
      var h, a, b;
      h = this.headers;
      for (a in s) {
        b = s[a];
        a = a.toLowerCase();
        if (!b) {
          if (h.hasOwnProperty(a)) {
            delete h[a];
          }
        } else {
          h[a] = b;
        }
      }
    }
  };
  FetchError = function(){
    var E;
    if (Error.captureStackTrace) {
      E = function(id, message, res){
        this.id = id;
        this.message = message;
        this.response = res || null;
        this.status = res ? res.status : 0;
        Error.captureStackTrace(this, FetchError);
      };
    } else {
      E = function(id, message, res){
        this.id = id;
        this.message = message;
        this.response = res || null;
        this.status = res ? res.status : 0;
        this.stack = new Error(message).stack;
      };
    }
    E.prototype = Error.prototype;
    return E;
  }();
  FetchData = function(){
    var ResponseData, RetryData, FetchData;
    ResponseData = function(){
      var RequestData, ResponseData;
      RequestData = function(){
        this.headers = null;
        this.data = null;
        this.crypto = null;
      };
      return ResponseData = function(){
        this.status = 0;
        this.type = null;
        this.headers = null;
        this.data = null;
        this.crypto = null;
        this.request = new RequestData();
      };
    }();
    RetryData = function(){
      this.count = 15;
      this.current = 0;
      this.expoBackoff = true;
      this.maxBackoff = 32;
      this.delay = 1;
    };
    return FetchData = function(config){
      var this$ = this;
      this.status200 = config.status200;
      this.fullHouse = config.fullHouse;
      this.notNull = config.notNull;
      this.promiseReject = config.promiseReject;
      this.timeout = 1000 * config.timeout;
      this.promise = null;
      this.response = new ResponseData();
      this.retry = new RetryData();
      this.aborter = null;
      this.timer = 0;
      this.timerFunc = this.timeout && function(force){
        if (force) {
          clearTimeout(this$.timer);
        } else {
          this$.aborter.abort();
        }
        this$.timer = 0;
      };
    };
  }();
  FetchHandler = function(config){
    var handler;
    handler = function(url, options, data, callback){
      var res, sec, responseHandler, decryptHandler, successHandler, errorHandler;
      res = data.response;
      sec = config.secret;
      responseHandler = function(r){
        var h, a, b;
        if (data.timer) {
          data.timerFunc(true);
        }
        if (!r.ok || (r.status !== 200 && data.status200)) {
          throw new FetchError(0, 'connection failed', r);
        }
        res.status = r.status;
        res.headers = h = {};
        a = r.headers.entries();
        while (!(b = a.next()).done) {
          h[b.value[0].toLowerCase()] = b.value[1];
        }
        if ((res.type = r.type) === 'opaque') {
          if (sec) {
            throw new FetchError(1, 'encrypted opaque response', res);
          }
          return r;
        }
        if (sec) {
          return r.arrayBuffer();
        }
        b = h['content-type'] || '';
        if (a = options.headers.accept) {
          if (b && a !== b) {
            throw new FetchError(1, 'incorrect content-type header', res);
          }
        } else {
          a = b;
        }
        switch (0) {
        case a.indexOf('application/json'):
          return r.text().then(jsonDecode);
        case a.indexOf('application/octet-stream'):
          return r.arrayBuffer();
        case a.indexOf('text/'):
          return r.text();
        case a.indexOf('image/'):
        case a.indexOf('audio/'):
        case a.indexOf('video/'):
          return r.blob();
        case a.indexOf('multipart/form-data'):
          return r.formData();
        default:
          return r.arrayBuffer();
        }
      };
      sec && (decryptHandler = function(buf){
        var a;
        if (buf.byteLength === 0) {
          return null;
        }
        a = sec.decrypt(buf, res.request.crypto.params);
        return a.data.then(function(d){
          var c;
          if ((a.data = d) === null) {
            sec.manager('fail');
            throw new FetchError(2, 'decryption failed', res);
          }
          res.crypto = a;
          sec.save();
          c = options.headers.accept || res.headers['content-type'] || '';
          switch (0) {
          case c.indexOf('application/json'):
            c = jsonDecode(d);
            break;
          case c.indexOf('text/'):
            c = textDecode(d);
            break;
          default:
            c = d;
          }
          return c;
        });
      });
      successHandler = function(d){
        var a;
        if (data.notNull && ((a = toString$.call(d).slice(8, -1)) === 'Null' || a === 'Blob' && a.size === 0 || a === 'ArrayBuffer' && a.byteLength === 0)) {
          throw new FetchError(1, 'empty response', res);
        }
        if (data.fullHouse) {
          res.data = d;
          d = res;
        }
        if (callback) {
          callback(true, d);
        } else {
          data.promise.pending = false;
          data.promise.resolve(d);
        }
      };
      errorHandler = function(e){
        if (options.signal.aborted) {
          e = data.timeout && !data.timer
            ? new FetchError(0, 'connection timed out', res)
            : new FetchError(4, e.message, res);
        }
        if (data.timer) {
          data.timerFunc(true);
        }
        if (!(e instanceof FetchError)) {
          e = new FetchError(5, e.message, res);
        }
        if (callback) {
          callback(false, e);
        } else {
          data.promise.pending = false;
          if (data.promiseReject) {
            data.promise.reject(e);
          } else {
            data.promise.resolve(e);
          }
        }
        /***
        # TODO: retry request?!
        # WARN: incorrect code below
        while true
        	# check for incorrect response
        	if not (e instanceof FetchError) or e.status == 0
        		break
        	# check limit
        	if not (a = data.retry).count or a.current < a.count
        		break
        	# determine delay
        	if a.expoBackoff
        		# exponential backoff algorithm
        		# https://cloud.google.com/storage/docs/exponential-backoff
        		b = 2**a.current + Math.floor (1001 * Math.random!)
        		b = a.maxBackoff if b > a.maxBackoff
        	else
        		# fixed delay
        		if typeof a.delay == 'number'
        			# simple
        			b = 1000*a.delay
        		else
        			# gradual
        			if a.current <= (b = a.delay.length - 1)
        				b = 1000*a.delay[a.current]
        			else
        				b = 1000*a.delay[b]
        	# increase current
        	++a.current
        	# activate re-try
        	setTimeout handlerFunc, b
        	return
        /***/
      };
      if (data.timeout) {
        data.timer = setTimeout(data.timerFunc, data.timeout);
      }
      if (sec) {
        fetch(url, options).then(responseHandler).then(decryptHandler).then(successHandler)['catch'](errorHandler);
      } else {
        fetch(url, options).then(responseHandler).then(successHandler)['catch'](errorHandler);
      }
    };
    this.config = config;
    this.api = new Api(this);
    this.fetch = function(){
      var o, d, e, options, callback, url, data, a, i$, ref$, len$, b, c;
      o = new FetchOptions();
      d = new FetchData(config);
      if ((e = parseArguments(arguments)) instanceof Error) {
        options = {};
        callback = false;
      } else {
        options = e[0];
        callback = e[1];
        e = false;
      }
      url = options.hasOwnProperty('url')
        ? config.baseUrl + options.url
        : config.baseUrl;
      if (options.hasOwnProperty('data')) {
        data = options.data;
      }
      if (options.hasOwnProperty('timeout') && (a = options.timeout) >= 0) {
        d.timeout = 1000 * a;
      }
      for (i$ = 0, len$ = (ref$ = config.flagOptions).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (options.hasOwnProperty(a)) {
          d[a] = !!options[a];
        }
      }
      for (i$ = 0, len$ = (ref$ = config.fetchOptions).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (options.hasOwnProperty(a)) {
          o[a] = options[a];
        } else if (config[a] !== null) {
          o[a] = config[a];
        }
      }
      if (options.hasOwnProperty('method')) {
        o.method = options.method;
      } else if (options.hasOwnProperty('data')) {
        o.method = 'POST';
      }
      d.response.request.headers = o.headers;
      if (config.headers) {
        o.setHeaders(config.headers);
      }
      if (toString$.call(options.headers).slice(8, -1) === 'Object') {
        o.setHeaders(options.headers);
      }
      if (data !== undefined && !e) {
        a = o.headers['content-type'];
        b = toString$.call(data).slice(8, -1);
        if (c = config.secret) {
          o.headers['content-encoding'] = 'aes256gcm';
          o.headers['etag'] = c.next().tag();
          switch (0) {
          case a.indexOf('application/x-www-form-urlencoded'):
            o.headers['content-type'] = 'application/json';
            // fallthrough
          case a.indexOf('application/json'):
            if (b !== 'String' && !(data = jsonEncode(data))) {
              e = new FetchError(3, 'failed to encode request data to JSON');
            }
            break;
          case a.indexOf('multipart/form-data'):
            if (b === 'String' || b === 'FormData') {
              e = new FetchError(3, 'encryption of prepared FormData is not supported');
            }
            delete o.headers['content-type'];
            break;
          default:
            if (b !== 'String' && b !== 'ArrayBuffer') {
              e = new FetchError(3, 'incorrect request raw data type');
            }
          }
        } else {
          switch (0) {
          case a.indexOf('application/json'):
            if (b !== 'String' && !(data = jsonEncode(data))) {
              e = new FetchError(3, 'failed to encode request data to JSON');
            }
            break;
          case a.indexOf('application/x-www-form-urlencoded'):
            if ((b !== 'String' && b !== 'URLSearchParams') && !(data = newQueryString(data))) {
              e = new FetchError(3, 'failed to encode request data to URLSearchParams');
            }
            break;
          case a.indexOf('multipart/form-data'):
            if ((b !== 'String' && b !== 'FormData') && !(data = newFormData(data))) {
              e = new FetchError(3, 'failed to encode request data to FormData');
            }
            if (b !== 'String') {
              delete o.headers['content-type'];
            }
            break;
          default:
            if (b !== 'String' && b !== 'ArrayBuffer') {
              e = new FetchError(3, 'incorrect request raw data type');
            }
          }
        }
        o.body = d.response.request.data = data;
      } else {
        delete o.headers['content-type'];
      }
      d.aborter = (a = options.aborter) && a instanceof AbortController
        ? a
        : new AbortController();
      o.signal = d.aborter.signal;
      if (!callback) {
        d.promise = newPromise(d.aborter);
      }
      /*** TODO: set retry
      # copy configuration
      a = d.retry
      if b = config.retry
      	for c of a
      		a[c] = b[c]
      # copy user options
      if b = options.retry
      	if typeof! b == 'Object'
      		for c of a when b.hasOwnProperty c
      			a[c] = b[c]
      	else
      		a.count = b
      # fix values
      a.current = 0
      a.maxBackoff = 1000 * a.maxBackoff
      /***/
      if (e) {
        if (callback) {
          callback(false, e);
          return d.aborter;
        } else {
          d.promise.pending = false;
          if (d.promiseReject) {
            d.promise.reject(e);
          } else {
            d.promise.resolve(e);
          }
          return d.promise;
        }
      }
      if (config.secret) {
        data = config.secret.encrypt(o.body, true);
        data.data.then(function(e){
          o.body = data.data = e;
          d.response.request.crypto = data;
          if (o.signal.aborted) {
            throw new FetchError(4, 'aborted programmatically');
          }
          handler(url, o, d, callback);
        })['catch'](function(e){
          if (callback) {
            callback(false, e);
          } else {
            d.promise.pending = false;
            if (d.promiseReject) {
              d.promise.reject(e);
            } else {
              d.promise.resolve(e);
            }
          }
        });
      } else {
        handler(url, o, d, callback);
      }
      return callback
        ? d.aborter
        : d.promise;
    };
  };
  FetchHandler.prototype = {};
  Api = function(handler){
    var handshakeLocked;
    this.create = newInstance(handler.config);
    this.json = function(){
      var a, b, c;
      if ((a = parseArguments(arguments)) instanceof Error) {
        return handler.fetch(a);
      }
      b = a[0];
      c = b.headers
        ? b.headers
        : {};
      c['content-type'] = 'application/json';
      a[0].headers = c;
      return handler.fetch(a[0], a[1]);
    };
    this.text = function(){
      var a, b, c;
      if ((a = parseArguments(arguments)) instanceof Error) {
        return handler.fetch(a);
      }
      b = a[0];
      c = b.headers
        ? b.headers
        : {};
      c['content-type'] = 'text/plain;charset=utf-8';
      a[0].headers = c;
      return handler.fetch(a[0], a[1]);
    };
    this.form = function(){
      var a, b, c;
      if ((a = parseArguments(arguments)) instanceof Error) {
        return handler.fetch(a);
      }
      b = a[0];
      c = b.headers
        ? b.headers
        : {};
      c['content-type'] = isFormData(b.data) ? 'multipart/form-data' : 'application/x-www-form-urlencoded';
      a[0].headers = c;
      return handler.fetch(a[0], a[1]);
    };
    if (!apiCrypto) {
      return;
    }
    handshakeLocked = false;
    this.handshake = async function(url, storeManager){
      var k, hash, x, c, b, a, i;
      if (handshakeLocked) {
        return false;
      }
      if (!storeManager) {
        if (k = handler.config.secret) {
          handler.config.secret = null;
          apiCrypto.secretManagersPool['delete'](k.manager);
          k.manager('destroy', '');
        }
        return true;
      }
      if (apiCrypto.secretManagersPool.has(storeManager)) {
        console.log('httpFetch: secret manager must be unique');
        return false;
      }
      handshakeLocked = true;
      if (k = storeManager('get')) {
        k = handler.config.secret = (await apiCrypto.newSecret(k, storeManager));
        handshakeLocked = false;
        return !!k;
      }
      if (!(hash = (await apiCrypto.generateHashPair()))) {
        handshakeLocked = false;
        return false;
      }
      x = false;
      c = 4;
      while (--c) {
        if (!(k = (await apiCrypto.generateKeyPair()))) {
          break;
        }
        b = {
          url: url,
          method: 'POST',
          data: k[1],
          headers: {
            'content-type': 'application/octet-stream',
            'etag': 'exchange'
          },
          fullHouse: false,
          timeout: 0
        };
        a = (await handler.fetch(b));
        if (!a || a instanceof Error) {
          break;
        }
        if ((a = (await apiCrypto.importKey(a))) === null) {
          break;
        }
        if ((a = (await apiCrypto.deriveKey(k[0], a))) === null) {
          break;
        }
        if ((k = (await apiCrypto.newSecret(a, storeManager))) === null) {
          break;
        }
        b.headers.etag = 'verify';
        if ((b.data = (await k.encrypt(hash[0]))) === null) {
          break;
        }
        a = (await handler.fetch(b));
        if (!a || !(a instanceof ArrayBuffer)) {
          break;
        }
        if ((i = a.byteLength) !== 0) {
          a = new Uint8Array(a);
          if ((b = hash[1]).byteLength !== i) {
            break;
          }
          while (--i >= 0) {
            if (a[i] !== b[i]) {
              break;
            }
          }
          if (i === -1) {
            x = true;
            break;
          }
        }
      }
      if (x && (handler.config.secret = k.save())) {
        apiCrypto.secretManagersPool.set(k.manager);
      }
      handshakeLocked = false;
      return x;
    };
  };
  ApiHandler = function(handler){
    this.get = function(f, key){
      switch (key) {
      case 'secret':
        return !!handler.config.secret;
      case 'prototype':
        return FetchHandler.prototype;
      default:
        if (handler.config.hasOwnProperty(key)) {
          return handler.config[key];
        }
      }
      if (handler.api[key]) {
        return handler.api[key];
      }
      return null;
    };
    this.set = function(f, key, val){
      if (handler.config.hasOwnProperty(key)) {
        switch (key) {
        case 'baseUrl':
          if (typeof val === 'string') {
            handler.config[key] = val;
          }
          break;
        case 'status200':
        case 'notNull':
        case 'fullHouse':
          handler.config[key] = !!val;
          break;
        case 'timeout':
          if ((val = parseInt(val)) >= 0) {
            handler.config[key] = val;
          }
        }
      }
      return true;
    };
  };
  ApiHandler.prototype = {
    setPrototypeOf: function(){
      return false;
    },
    getPrototypeOf: function(){
      return FetchHandler.prototype;
    }
  };
  newFormData = function(){
    var add;
    add = function(data, item, key){
      var b, i$, len$, a;
      switch (toString$.call(item).slice(8, -1)) {
      case 'Object':
        b = Object.getOwnPropertyNames(item);
        if (key) {
          for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
            a = b[i$];
            add(data, item[a], key + '[' + a + ']');
          }
        } else {
          for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
            a = b[i$];
            add(data, item[a], a);
          }
        }
        break;
      case 'Array':
        key = key ? key + '[]' : '';
        b = item.length;
        a = -1;
        while (++a < b) {
          add(data, item[a], key);
        }
        break;
      case 'HTMLInputElement':
        if (item.type === 'file' && item.files.length) {
          add(data, item.files, key);
        }
        break;
      case 'FileList':
        if ((b = item.length) === 1) {
          data.append(key, item[0]);
        } else {
          a = -1;
          while (++a < b) {
            data.append(key + '[]', item[a]);
          }
        }
        break;
      case 'Null':
        data.append(key, '');
        break;
      default:
        data.append(key, item);
      }
      return data;
    };
    return function(o){
      return add(new FormData(), o, '');
    };
  }();
  newQueryString = function(){
    var add;
    add = function(list, item, key){
      var b, i$, len$, a;
      switch (toString$.call(item).slice(8, -1)) {
      case 'Object':
        b = Object.getOwnPropertyNames(item);
        if (key) {
          for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
            a = b[i$];
            add(list, item[a], key + '[' + a + ']');
          }
        } else {
          for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
            a = b[i$];
            add(list, item[a], a);
          }
        }
        break;
      case 'Array':
        key = key ? key + '[]' : '';
        b = item.length;
        a = -1;
        while (++a < b) {
          add(list, item[a], key);
        }
        break;
      case 'Null':
        list[list.length] = encodeURIComponent(key) + '=';
        break;
      default:
        list[list.length] = encodeURIComponent(key) + '=' + encodeURIComponent(item);
      }
      return list;
    };
    return function(o){
      return add([], o, '').join('&');
    };
  }();
  newPromise = function(aborter){
    var a, b, p;
    a = b = null;
    p = new Promise(function(resolve, reject){
      a = resolve;
      b = reject;
    });
    p.resolve = a;
    p.reject = b;
    p.pending = true;
    p.controller = aborter;
    p.abort = p.cancel = function(){
      aborter.abort();
    };
    return p;
  };
  newInstance = function(baseConfig){
    return function(userConfig){
      var config, a, b;
      config = new FetchConfig();
      if (baseConfig) {
        config.setOptions(baseConfig);
      }
      if (userConfig) {
        config.setOptions(userConfig);
      }
      a = new FetchHandler(config);
      b = new ApiHandler(a);
      return new Proxy(a.fetch, b);
    };
  };
  return newInstance(null)(null);
}();
if (httpFetch && typeof module !== 'undefined') {
  module.exports = httpFetch;
}