// Generated by LiveScript 1.6.0
'use strict';
var httpFetch, toString$ = {}.toString;
httpFetch = function(){
  var api, Config, FetchOptions, FetchError, HandlerOptions, textParser, fetchHandler, newInstance, Api, apiHandler;
  api = {};
  api[typeof fetch] = true;
  api[typeof AbortController] = true;
  api[typeof Proxy] = true;
  if (api['undefined']) {
    console.log('httpFetch: missing requirements');
    return null;
  }
  Config = function(){
    this.baseUrl = '';
    this.timeout = 20;
    this.only200 = true;
    this.headers = null;
  };
  FetchOptions = function(method){
    this.method = method;
    this.body = null;
    this.signal = null;
    this.headers = {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    };
  };
  FetchError = function(){
    var E;
    if (Error.captureStackTrace) {
      E = function(message, status){
        this.name = 'FetchError';
        this.message = message;
        this.status = status;
        Error.captureStackTrace(this, FetchError);
      };
    } else {
      E = function(message, status){
        this.name = 'FetchError';
        this.message = message;
        this.status = status;
        this.stack = new Error(message).stack;
      };
    }
    E.prototype = Error.prototype;
    return E;
  }();
  HandlerOptions = function(url, method, timeout){
    this.url = url;
    this.method = method;
    this.data = '';
    this.timeout = timeout;
  };
  textParser = function(r){
    var e;
    if (r) {
      try {
        return JSON.parse(r);
      } catch (e$) {
        e = e$;
        throw new Error('Incorrect response body: ' + e.message + ': ' + r);
      }
    }
    return null;
  };
  fetchHandler = function(config){
    var responseHandler;
    responseHandler = function(r){
      if (!r.ok || (r.status !== 200 && config.only200)) {
        throw new FetchError(r.statusText, r.status);
      }
      return r.text().then(textParser);
    };
    return function(options, callback){
      var a, o, aController, timeout;
      if (toString$.call(options).slice(8, -1) !== 'Object' || typeof callback !== 'function') {
        return null;
      }
      a = options.hasOwnProperty('method')
        ? options.method
        : options.data ? 'POST' : 'GET';
      o = new FetchOptions(a);
      if (config.headers) {
        import$(o.headers, config.headers);
      }
      if (options.headers) {
        import$(o.headers, options.headers);
      }
      if (options.data) {
        o.body = typeof options.data === 'string'
          ? options.data
          : JSON.stringify(options.data);
      }
      aController = new AbortController();
      o.signal = aController.signal;
      a = options.hasOwnProperty('timeout')
        ? options.timeout
        : config.timeout;
      if (a >= 1) {
        timeout = setTimeout(function(){
          aController.abort();
        }, 1000 * a);
      }
      a = options.url
        ? config.baseUrl + options.url
        : config.baseUrl;
      fetch(a, o).then(responseHandler).then(function(r){
        if (timeout) {
          clearTimeout(timeout);
        }
        callback(true, r);
      })['catch'](function(e){
        callback(false, e);
      });
      return aController;
    };
  };
  newInstance = function(config){
    var c, a, h;
    c = new Config();
    for (a in c) {
      if (config.hasOwnProperty(a)) {
        c[a] = config[a];
      }
    }
    h = fetchHandler(c);
    h.config = c;
    h.api = new Api(h);
    return new Proxy(h, apiHandler);
  };
  Api = function(handler){
    this.post = function(url, data, callback){
      var options;
      options = new HandlerOptions(url, 'POST', handler.config.timeout);
      if (data) {
        options.data = data;
      }
      return handler(options, callback);
    };
    this.get = function(url, callback){
      return handler(new HandlerOptions(url, 'GET', handler.config.timeout), callback);
    };
    this.create = newInstance;
  };
  apiHandler = {
    get: function(me, key){
      if (typeof me.api[key] === 'function') {
        return me.api[key];
      }
      if (me.config.hasOwnProperty(key)) {
        return me.config[key];
      }
      return null;
    },
    set: function(me, key, val){
      return true;
    }
  };
  return newInstance(new Config());
}();
if (httpFetch && typeof module !== 'undefined') {
  module.exports = httpFetch;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}